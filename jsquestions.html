<!DOCTYPE html>
   <html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">

      <!--=============== CSS ===============-->
      <link rel="stylesheet" href="assets/css/styles.css">

      <title>Теоретическая подготовка</title>
   </head>
   <header>
      <nav class = "navbar">
         <div class = "container">
            <a href = "index.html" class = "navbar-brand">I'LL CALL YOU LATER</a>

            <div class = "navbar-wrap">
               <ul class = "navbar-menu">
                  <li><a href = "#"></a></li>
                  <li><a href = "#"></a></li>
                  <li><a href = "#">Учебник</a></li>
               </ul>
            </div>
         </div>
      </nav>
   </header>
   <body>
    <div class = "wrapper-questions">
        <br>
        <a href = "#1">1. В чем разница между null и undefined?</a>
        <br>
        <a href = "#2">2. Для чего используется оператор "&&"?</a>
        <br>
        <a href = "#3">3. Для чего используется оператор "||"?</a>
        <br>
        <a href = "#4">4. Является ли использование унарного плюса (оператор "+") самым быстрым способом преобразования строки в число?</a>
        <br>
        <a href = "#5">5. Что такое DOM?</a>
        <br>
        <a href = "#6">6. Что такое распространение события (Event Propogation)?</a>
        <br>
        <a href = "#7">7. Что такое всплытие события (Event Bubbling)?</a>
        <br>
        <a href = "#8">8. Что такое погружение события (Event Capturing)?</a>
        <br>
        <a href = "#9">9. В чем разница между методами event.preventDefault() и event.stopPropagation()?</a>
        <br>
        <a href = "#10">10. Как узнать об использовании метода event.preventDefault()?</a>
        <br>
        <a href = "#11">11. Почему obj.someprop.x приводит к ошибке?</a>
        <br>
        <a href = "#12">12. Что такое цель события или целевой элемент (event.target)?</a>
        <br>
        <a href = "#13">13. Что такое текущая цель события (event.currentTarget)?</a>
        <br>
        <a href = "#14">14. В чем разница между операторами "==" и "==="?</a>
        <br>
        <a href = "#15">15. Почему результатом сравнения двух похожих объектов является false?</a>
        <br>
        <a href = "#16">16. Для чего используется оператор "!!"?</a>
        <br>
        <a href = "#17">17. Как записать несколько выражений в одну строку?</a>
        <br>
        <a href = "#18">18. Что такое поднятие (Hoisting)?</a>
        <br>
        <a href = "#19">19. Что такое область видимости (Scope)?</a>
        <br>
        <a href = "#20">20. Что такое замыкание (Closures)?</a>
        <br>
        <a href = "#21">21. Какие значения в JS являются ложными?</a>
        <br>
        <a href = "#22">22. Как проверить, является ли значение ложным?</a>
        <br>
        <a href = "#23">23. Для чего используется директива «use strict»?</a>
        <br>
        <a href = "#24">24. Какое значение имеет this?</a>
        <br>
        <a href = "#25">25. Что такое прототип объекта?</a>
        <br>
        <a href = "#26">26. Что такое IIFE?</a>
        <br>
        <a href = "#27">27. Для чего используется метод Function.prototype.apply?</a>
        <br>
        <a href = "#28">28. Для чего используется метод Function.prototype.call?</a>
        <br>
        <a href = "#29">29. В чем разница между методами call и apply?</a>
        <br>
        <a href = "#30">30. Для чего используется метод Function.prototype.bind?</a>
        <br>
        <a href = "#31">31. Что такое функциональное программирование и какие особенности JS позволяют говорить о нем как о функциональном языке программирования?</a>
        <br>
        <a href = "#32">32. Что такое функции высшего порядка (Higher Order Functions)?</a>
        <br>
        <a href = "#33">33. Почему функции в JS называют объектами первого класса (First-class Objects)?</a>
        <br>
        <a href = "#34">34. Как бы Вы реализовали метод Array.prototype.map?</a>
        <br>
        <a href = "#35">35. Как бы Вы реализовали метод Array.prototype.filter?</a>
        <br>
        <a href = "#36">36. Как бы Вы реализовали метод Array.prototype.reduce?</a>
        <br>
        <a href = "#37">37. Что такое объект arguments?</a>
        <br>
        <a href = "#38">38. Как создать объект, не имеющий прототипа?</a>
        <br>
        <a href = "#39">39. Почему в представленном коде переменная b становится глобальной при вызове функции?</a>
        <br>
        <a href = "#40">40. Что такое ECMAScript?</a>
        <br>
        <a href = "#41">41. Что нового привнес в JS стандарт ES6 или ECMAScript2015?</a>
        <br>
        <a href = "#42">42. В чем разница между ключевыми словами «var», «let» и «const»?</a>
        <br>
        <a href = "#43">43. Что такое стрелочные функции (Arrow Functions)?</a>
        <br>
        <a href = "#44">44. Что такое классы (Classes)?</a>
        <br>
        <a href = "#45">45. Что такое шаблонные литералы (Template Literals)?</a>
        <br>
        <a href = "#46">46. Что такое деструктуризация объекта (Object Destructuring)?</a>
        <br>
        <a href = "#47">47. Что такое модули (Modules)?</a>
        <br>
        <a href = "#48">48. Что такое объект Set?</a>
        <br>
        <a href = "#49">49. Что такое функция обратного вызова (Callback Function)?</a>
        <br>
        <a href = "#50">50. Что такое промисы (Promises)?</a>
        <br>
        <a href = "#51">51. Что такое async/await?</a>
        <br>
        <a href = "#52">52. В чем разница между spread-оператором и rest-оператором?</a>
        <br>
        <a href = "#53">53. Что такое параметры по умолчанию (Default Parameters)?</a>
        <br>
        <a href = "#54">54. Что такое объектная обертка (Wrapper Objects)?</a>
        <br>
        <a href = "#55">55. В чем разница между явным и неявным преобразованием или приведением к типу (Implicit and Explicit Coercion)?</a>
        <br>
        <a href = "#56">56. Что такое NaN? Как проверить, является ли значение NaN?</a>
        <br>
        <a href = "#57">57. Как проверить, является ли значение массивом?</a>
        <br>
        <a href = "#58">58. Как проверить, что число является четным, без использования деления по модулю или деления с остатком (оператора "%")?</a>
        <br>
        <a href = "#59">59. Как определить наличие свойства в объекте?</a>
        <br>
        <a href = "#60">60. Что такое AJAX?</a>
        <br>
        <a href = "#61">61. Как в JS создать объект?</a>
        <br>
        <a href = "#62">62. В чем разница между методами Object.freeze и Object.seal?</a>
        <br>
        <a href = "#63">63. В чем разница между оператором «in» и методом hasOwnProperty?</a>
        <br>
        <a href = "#64">64. Какие приемы работы с асинхронным кодом в JS Вы знаете?</a>
        <br>
        <a href = "#65">65. В чем разница между обычной функцией и функциональным выражением?</a>
        <br>
        <a href = "#66">66. Как в JS вызвать функцию?</a>
        <br>
        <a href = "#67">67. Что такое запоминание или мемоизация (Memoization)?</a>
        <br>
        <a href = "#68">68. Как бы Вы реализовали вспомогательную функцию запоминания?</a>
        <br>
        <a href = "#69">69. Почему typeof null возвращает object? Как проверить, является ли значение null?</a>
        <br>
        <a href = "#70">70. Для чего используется ключевое слово «new»?</a>
        <br>
        <br>
        <a name="1"></a><h4>1. В чем разница между null и undefined?</h4><br/>
        Для начала давайте поговорим о том, что у них общего.<br/>
        <br/>
        Во-первых, они принадлежат к 7 «примитивам» (примитивным типам) JS:<br/>
        <br/>
        <pre><code class="javascript">let primitiveTypes = ['string', 'number', 'null', 'undefined', 'boolean', 'symbol', 'bigint']
        </code></pre><br/>
        Во-вторых, они являются ложными значениями, т.е. результатом их преобразования в логическое значение с помощью Boolean() или оператора "!!" является false:<br/>
        <br/>
        <pre><code class="javascript">console.log(!!null) // false
        console.log(!!undefined) // false
        
        console.log(Boolean(null)) // false
        console.log(Boolean(undefined)) // false
        </code></pre><br/>
        Ладно, теперь о различиях.<br/>
        <br/>
        undefined («неопределенный») представляет собой значение по умолчанию:<br/>
        <ul>
        <li>переменной, которой не было присвоено значения, т.е. объявленной, но не инициализированной переменной;</li>
        <li>функции, которая ничего не возвращает явно, например, console.log(1);</li>
        <li>несуществующего свойства объекта.</li>
        </ul><br/>
        В указанных случаях движок JS присваивает значение undefined.<br/>
        <br/>
        <pre><code class="javascript">let _thisIsUndefined
        const doNothing = () => {}
        const someObj = {
            a: 'ay',
            b: 'bee',
            c: 'si'
        }
        console.log(_thisIsUndefined) // undefined
        console.log(doNothing()) // undefined
        console.log(someObj['d']) // undefined
        </code></pre><br/>
        null — это «значение отсутствия значения». null — это значение, которое присваивается переменной явно. В примере ниже мы получаем null, когда метод fs.readFile отрабатывает без ошибок:<br/>
        <br/>
        <pre><code class="javascript">fs.readFile('path/to/file', (e, data) => {
            console.log(e) // здесь мы получаем null
        if(e) {
            console.log(e)
        }
            console.log(data)
        })
        </code></pre><br/>
        При сравнении null и undefined мы получаем true, когда используем оператор "==", и false при использовании оператора "===". О том, почему так происходит, см. ниже.<br/>
        <br/>
        <pre><code class="javascript">console.log(null == undefined) // true
        console.log(null === undefined) // false
        </code></pre><br/>
        <a name="2"></a><h4>2. Для чего используется оператор "&amp;&amp;"?</h4><br/>
        Оператор "&amp;&amp;" (логическое и) находит и возвращает первое ложное значение либо последний операнд, когда все значения истинные. Он использует короткое замыкание во избежание лишних затрат:<br/>
        <br/>
        <pre><code class="javascript">console.log(false &amp;&amp; 1 &amp;&amp; []) // false
        console.log(' ' &amp;&amp; true &amp;&amp; 5) // 5
        </code></pre><br/>
        С оператором «if»:<br/>
        <br/>
        <pre><code class="javascript">const router: Router = Router()
        
        router.get('/endpoint', (req: Request, res: Response) => {
            let conMobile: PoolConnection
            try {
                // операции с базой данных
            } catch (e) {
                if (conMobile) {
                    conMobile.release()
                }
            }
        })
        </code></pre><br/>
        То же самое с оператором "&amp;&amp;":<br/>
        <br/>
        <pre><code class="javascript">const router: Router = Router()
        
        router.get('/endpoint', (req: Request, res: Response) => {
            let conMobile: PoolConnection
            try {
                // операции с базой данных
            } catch (e) {
                conMobile &amp;&amp; conMobile.release()
            }
        })
        </code></pre><br/>
        <a name="3"></a><h4>3. Для чего используется оператор "||"?</h4><br/>
        Оператор "||" (логическое или) находит и возвращает первое истинное значение. Он также использует короткое замыкание. Данный оператор использовался для присвоения параметров по умолчанию в функциях до того, как параметры по умолчанию были стандартизированы в ES6.<br/>
        <br/>
        <pre><code class="javascript">console.log(null || 1 || undefined) // 1
        
        function logName(name) {
            let n = name || Mark
            console.log(n)
        }
        
        logName() // Mark
        </code></pre><br/>
        <a name="4"></a><h4>4. Является ли использование унарного плюса (оператор "+") самым быстрым способом преобразования строки в число?</h4><br/>
        Согласно <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Unary_plus" rel="nofollow">MDN</a> оператор "+" действительно является самым быстрым способом преобразования строки в число, поскольку он не выполняет никаких операций со значением, которое является числом.<br/>
        <br/>
        <a name="5"></a><h4>5. Что такое DOM?</h4><br/>
        DOM или Document Object Model (объектная модель документа) — это прикладной программный интерфейс (API) для работы с HTML и XML документами. Когда браузер первый раз читает («парсит») HTML документ, он формирует большой объект, действительно большой объект, основанный на документе — DOM. DOM представляет собой древовидную структуру (дерево документа). DOM используется для взаимодействия и изменения самой структуры DOM или его отдельных элементов и узлов.<br/>
        <br/>
        Допустим, у нас есть такой HTML:<br/>
        <br/>
        <pre><code class="xml">&lt;!DOCTYPE html>
        &lt;html lang="en">
        
        &lt;head>
            &lt;meta charset="UTF-8">
            &lt;meta name="viewport" content="width=device-width">
            &lt;meta http-equiv="X-UA-Compatible" content="ie=edge">
            &lt;title>Document Object Model&lt;/title>
        &lt;/head>
        
        &lt;body>
            &lt;div>
                &lt;p>
                    &lt;span>&lt;/span>
                &lt;/p>
                &lt;label>&lt;/label>
                &lt;input>
            &lt;/div>
        &lt;/body>
        
        &lt;/html>
        </code></pre><br/>
        DOM этого HTML выглядит так:<br/>
        <br/>
        <img src="https://habrastorage.org/r/w1560/webt/ax/cg/id/axcgidsa8fghreeuyvbhfpga6yo.png" data-src="https://habrastorage.org/webt/ax/cg/id/axcgidsa8fghreeuyvbhfpga6yo.png"/><br/>
        <br/>
        В JS DOM представлен объектом Document. Объект Document имеет большое количество методов для работы с элементами, их созданием, модификацией, удалением и т.д.<br/>
        <br/>
        <a name="6"></a><h4>6. Что такое распространение события (Event Propagation)?</h4><br/>
        Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие «распространяется» от объекта Window до вызвавшего его элемента (event.target). При этом событие последовательно пронизывает (затрагивает) всех предков целевого элемента. Распространение события имеет три стадии или фазы:<br/>
        <ol>
        <li>Фаза погружения (захвата, перехвата) — событие возникает в объекте Window и опускается до цели события через всех ее предков.</li>
        <li>Целевая фаза — это когда событие достигает целевого элемента.</li>
        <li>Фаза всплытия — событие поднимается от event.target, последовательно проходит через всех его предков и достигает объекта Window.</li>
        </ol><br/>
        <img src="https://habrastorage.org/r/w1560/webt/a3/9x/67/a39x67wkxdmcyzj-it5m2jmfxgg.png" data-src="https://habrastorage.org/webt/a3/9x/67/a39x67wkxdmcyzj-it5m2jmfxgg.png"/><br/>
        <br/>
        Подробнее о распространении событий можно почитать <a href="https://learn.javascript.ru/bubbling-and-capturing" rel="nofollow">здесь</a> и <a href="https://www.w3.org/TR/DOM-Level-3-Events/#event-flow" rel="nofollow">здесь</a>.<br/>
        <br/>
        <a name="7"></a><h4>7. Что такое всплытие события?</h4><br/>
        Когда событие происходит в элементе DOM, оно затрагивает не только этот элемент. Событие «всплывает» (подобно пузырьку воздуха в воде), переходит от элемента, вызвавшего событие (event.target), к его родителю, затем поднимается еще выше, к родителю родителя элемента, пока не достигает объекта Window.<br/>
        <br/>
        Допустим, у нас есть такая разметка:<br/>
        <br/>
        <pre><code class="xml">&lt;div class="grandparent">
            &lt;div class="parent">
                &lt;div class="child">1&lt;/div>
            &lt;/div>
        &lt;/div>
        </code></pre><br/>
        И такой JS:<br/>
        <br/>
        <pre><code class="javascript">function addEvent(el, event, callback, isCapture = false) {
            if (!el || !event || !callback || typeof callback !== 'function') return
        
            if (typeof el === 'string') {
                el = document.querySelector(el)
            }
            el.addEventListener(event, callback, isCapture)
        }
        
        addEvent(document, 'DOMContentLoaded', () => {
            const child = document.querySelector('.child')
            const parent = document.querySelector('.parent')
            const grandparent = document.querySelector('.grandparent')
        
            addEvent(child, 'click', function(e) {
                console.log('child')
            })
        
            addEvent(parent, 'click', function(e) {
                console.log('parent')
            })
        
            addEvent(grandparent, 'click', function(e) {
                console.log('grandparent')
            })
        
            addEvent('html', 'click', function(e) {
                console.log('html')
            })
        
            addEvent(document, 'click', function(e) {
                console.log('document')
            })
        
            addEvent(window, 'click', function(e) {
                console.log('window')
            })
        })
        </code></pre><br/>
        У метода addEventListener есть третий необязательный параметр — useCapture. Когда его значение равняется false (по умолчанию), событие начинается с фазы всплытия. Когда его значение равняется true, событие начинается с фазы погружения (для «прослушивателей» событий, прикрепленных к цели события, событие находится в целевой фазе, а не в фазах погружения или всплытия. События в целевой фазе инициируют все прослушиватели на элементе в том порядке, в котором они были зарегистрированы независимо от параметра useCapture — прим. пер.). Если мы кликнем по элементу child, в консоль будет выведено: child, parent, grandparent, html, document, window. Вот что такое всплытие события.<br/>
        <br/>
        <a name="8"></a><h4>8. Что такое погружение события?</h4><br/>
        Когда событие происходит в элементе DOM, оно происходит не только в нем. В фазе погружения событие опускается от объекта Window до цели события через всех его предков.<br/>
        <br/>
        Разметка:<br/>
        <br/>
        <pre><code class="xml">&lt;div class="grandparent">
            &lt;div class="parent">
                &lt;div class="child">1&lt;/div>
            &lt;/div>
        &lt;/div>
        </code></pre><br/>
        JS:<br/>
        <br/>
        <pre><code class="javascript">function addEvent(el, event, callback, isCapture = false) {
            if (!el || !event || !callback || typeof callback !== 'function') return
        
            if (typeof el === 'string') {
                el = document.querySelector(el);
            }
            el.addEventListener(event, callback, isCapture)
        }
        
        addEvent(document, 'DOMContentLoaded', () => {
            const child = document.querySelector('.child')
            const parent = document.querySelector('.parent')
            const grandparent = document.querySelector('.grandparent')
        
            addEvent(child, 'click', function(e) {
                console.log('child');
            }, true)
        
            addEvent(parent, 'click', function(e) {
                console.log('parent')
            }, true)
        
            addEvent(grandparent, 'click', function(e) {
                console.log('grandparent')
            }, true)
        
            addEvent('html', 'click', function(e) {
                console.log('html')
            }, true)
        
            addEvent(document, 'click', function(e) {
                console.log('document')
            }, true)
        
            addEvent(window, 'click', function(e) {
                console.log('window')
            }, true)
        })
        </code></pre><br/>
        У метода addEventListener есть третий необязательный параметр — useCapture. Когда его значение равняется false (по умолчанию), событие начинается с фазы всплытия. Когда его значение равняется true, событие начинается с фазы погружения. Если мы кликнем по элементу child, то увидим в консоли следующее: window, document, html, grandparent, parent, child. Это и есть погружение события.<br/>
        <br/>
        <a name="9"></a><h4>9. В чем разница между методами event.preventDefault() и event.stopPropagation()?</h4><br/>
        Метод event.preventDefault() отключает поведение элемента по умолчанию. Если использовать этот метод в элементе form, то он предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет отключено (данный метод часто используется в keydown для переопределения клавиатуры, например, при создании музыкального/видео плеера или текстового редактора — прим. пер.). Метод event.stopPropagation() отключает распространение события (его всплытие или погружение).<br/>
        <br/>
        <a name="10"></a><h4>10. Как узнать об использовании метода event.preventDefault()?</h4><br/>
        Для этого мы можем использовать свойство event.defaulPrevented, возвращающее логическое значение, служащее индикатором применения к элементу метода event.preventDefault.<br/>
        <br/>
        <a name="11"></a><h4>11. Почему obj.someprop.x приводит к ошибке?</h4><br/>
        <br/>
        <pre><code class="javascript">const obj = {}
        console.log(obj.someprop.x)
        </code></pre><br/>
        Ответ очевиден: мы пытается получить доступ к свойству x свойства someprop, которое имеет значение undefined. obj.__proto__.__proto = null, поэтому возвращается undefined, а у undefined нет свойства x.<br/>
        <br/>
        <a name="12"></a><h4>12. Что такое цель события или целевой элемент (event.target)?</h4><br/>
        Простыми словами, event.target — это элемент, в котором происходит событие, или элемент, вызвавший событие.<br/>
        <br/>
        Имеем такую разметку:<br/>
        <br/>
        <pre><code class="xml">&lt;div onclick="clickFunc(event)" style="text-align: center; margin: 15px;
        border: 1px solid red; border-radius: 3px;">
            &lt;div style="margin: 25px; border: 1px solid royalblue; border-radius: 3px;">
                &lt;div style="margin: 25px; border: 1px solid skyblue; border-radius: 3px;">
                    &lt;button style="margin: 10px">
                        Button
                    &lt;/button>
                &lt;/div>
            &lt;/div>
        &lt;/div>
        </code></pre><br/>
        И такой простенький JS:<br/>
        <br/>
        <pre><code class="javascript">function clickFunc(event) {
            console.log(event.target)
        }
        </code></pre><br/>
        Мы прикрепили «слушатель» к внешнему div. Однако если мы нажмем на кнопку, то получим в консоли разметку этой кнопки. Это позволяет сделать вывод, что элементом, вызвавшим событие, является именно кнопка, а не внешний или внутренние div.<br/>
        <br/>
        <a name="13"></a><h4>13. Что такое текущая цель события (event.currentTarget)?</h4><br/>
        Event.currentTarget — это элемент, к которому прикреплен прослушиватель событий.<br/>
        <br/>
        Аналогичная разметка:<br/>
        <br/>
        <pre><code class="xml">&lt;div onclick="clickFunc(event)" style="text-align: center;margin:15px;
        border:1px solid red;border-radius:3px;">
            &lt;div style="margin: 25px; border:1px solid royalblue;border-radius:3px;">
                &lt;div style="margin:25px;border:1px solid skyblue;border-radius:3px;">
                    &lt;button style="margin:10px">
                        Button
                    &lt;/button>
                &lt;/div>
            &lt;/div>
        &lt;/div>
        </code></pre><br/>
        И немного видоизмененный JS:<br/>
        <br/>
        <pre><code class="javascript">function clickFunc(event) {
            console.log(event.currentTarget)
        }
        </code></pre><br/>
        Мы прикрепили слушатель к внешнему div. Куда бы мы ни кликнули, будь то кнопка или один из внутренних div, в консоли мы всегда получим разметку внешнего div. Это позволяет заключить, что event.currentTarget — это элемент, к которому прикреплен прослушиватель событий.<br/>
        <br/>
        <a name="14"></a><h4>14. В чем разница между операторами "==" и "==="?</h4><br/>
        Разница между оператором "==" (абстрактное или нестрогое равенство) и оператором "===" (строгое равенство) состоит в том, что первый сравнивает значения после их преобразования или приведения к одному типу (Coersion), а второй — без такого преобразования.<br/>
        <br/>
        Давайте копнем глубже. И сначала поговорим о преобразовании.<br/>
        <br/>
        Преобразование представляет собой процесс приведения значения к другому типу или, точнее, процесс приведения сравниваемых значений к одному типу. При сравнении оператор "==" производит так называемое неявное сравнение. Оператор "==" выполняет некоторые операции перед сравнением двух значений.<br/>
        <br/>
        Допустим, мы сравниваем x и y.<br/>
        <br/>
        Алгоритм следующий:<br/>
        <br/>
        <ol>
        <li>Если x и y имеют одинаковый тип, сравнение выполняется с помощью оператора "===".</li>
        <li>Если x = null и y = undefined возвращается true.</li>
        <li>Если x = undefined и y = null возвращается true.</li>
        <li>Если x = число, а y = строка, возвращается x == toNumber(y) (значение y преобразуется в число).</li>
        <li>Если x = строка, а y = число, возвращается toNumber(x) == y (значение x преобразуется в число).</li>
        <li>Если x = логическое значение, возвращается toNumber(x) == y.</li>
        <li>Если y = логическое значение, возвращается x == toNumber(y).</li>
        <li>Если x = строка, символ или число, а y = объект, возвращается x == toPrimitive(y) (значение y преобразуется в примитив).</li>
        <li>Если x = объект, а y = строка, символ или число, возвращается toPrimitive(x) == y.</li>
        <li>Возвращается false.</li>
        </ol><br/>
        Запомните: для приведения объекта к «примитиву» метод toPrimitive сначала использует метод valueOf, затем метод toString.<br/>
        <br/>
        Примеры:<br/>
        <br/>
        <img src="https://habrastorage.org/r/w1560/webt/yd/xe/tn/ydxetnfghjtfuex_p-em8v4emck.png" data-src="https://habrastorage.org/webt/yd/xe/tn/ydxetnfghjtfuex_p-em8v4emck.png"/><br/>
        <br/>
        Все примеры возвращают true.<br/>
        <br/>
        Первый пример — первое условие алгоритма.<br/>
        Второй пример — четвертое условие.<br/>
        Третий — второе.<br/>
        Четвертый — седьмое.<br/>
        Пятый — восьмое.<br/>
        И последний — десятое.<br/>
        <br/>
        <img src="https://habrastorage.org/r/w1560/webt/t-/4k/ys/t-4kyszb4grfafbi7lazyyvq6dy.png" data-src="https://habrastorage.org/webt/t-/4k/ys/t-4kyszb4grfafbi7lazyyvq6dy.png"/><br/>
        <br/>
        Если же мы используем оператор "===" все примеры, кроме первого, вернут false, поскольку значения в этих примерах имеют разные типы.<br/>
        <br/>
        <a name="15"></a><h4>15. Почему результатом сравнения двух похожих объектов является false?</h4><br/>
        <pre><code class="javascript">let a = {
            a: 1
        }
        let b = {
            a: 1
        }
        let c = a
        
        console.log(a === b) // false
        console.log(a === c) // true хм...
        </code></pre><br/>
        В JS объекты и примитивы сравниваются по-разному. Примитивы сравниваются по значению. Объекты — по ссылке или адресу в памяти, где хранится переменная. Вот почему первый console.log возвращает false, а второй — true. Переменные «a» и «c» ссылаются на один объект, а переменные «a» и «b» — на разные объекты с одинаковыми свойствами и значениями.<br/>
        <br/>
        <a name="16"></a><h4>16. Для чего используется оператор "!!"?</h4><br/>
        Оператор "!!" (двойное отрицание) приводит значение справа от него к логическому значению.<br/>
        <br/>
        <pre><code class="javascript">console.log(!!null) // false
        console.log(!!undefined) // false
        console.log(!!'') // false
        console.log(!!0) // false
        console.log(!!NaN) // false
        console.log(!!' ') // true
        console.log(!!{}) // true
        console.log(!![]) // true
        console.log(!!1) // true
        console.log(!![].length) // false
        </code></pre><br/>
        <a name="17"></a><h4>17. Как записать несколько выражений в одну строку?</h4><br/>
        Для этого мы можем использовать оператор "," (запятая). Этот оператор «двигается» слева направо и возвращает значение последнего выражения или операнда.<br/>
        <br/>
        <pre><code class="javascript">let x = 5
        
        x = (x++, x = addFive(x), x *= 2, x -= 5, x += 10)
        
        function addFive(num) {
            return num + 5
        }
        </code></pre><br/>
        Если мы выведем значение x в консоль, то получим 27. Сначала мы увеличиваем значение x на единицу (x = 6). Затем вызываем функцию addFive() с параметром 6, к которому прибавляем 5 (x = 11). После этого мы умножаем значение x на 2 (x = 22). Затем вычитаем 5 (x = 17). И, наконец, прибавляем 10 (x = 27).<br/>
        <br/>
        <a name="18"></a><h4>18. Что такое поднятие (Hoisting)?</h4><br/>
        Поднятие — это термин, описывающий подъем переменной или функции в глобальную или функциональную области видимости.<br/>
        <br/>
        Для того, чтобы понять, что такое Hoisting, необходимо разобраться с тем, что представляет собой контекст выполнения.<br/>
        <br/>
        Контекст выполнения — это среда, в которой выполняется код. Контекст выполнения имеет две фазы — компиляция и собственно выполнение.<br/>
        <br/>
        Компиляция. В этой фазе функциональные выражения и переменные, объявленные с помощью ключевого слова «var», со значением undefined поднимаются в самый верх глобальной (или функциональной) области видимости (как бы перемещаются в начало нашего кода. Это объясняет, почему мы можем вызывать функции до их объявления — прим. пер.).<br/>
        <br/>
        Выполнение. В этой фазе переменным присваиваются значения, а функции (или методы объектов) вызываются или выполняются.<br/>
        <br/>
        Запомните: поднимаются только функциональные выражения и переменные, объявленные с помощью ключевого слова «var». Обычные функции и стрелочные функции, а также переменные, объявленные с помощью ключевых слов «let» и «const» не поднимаются.<br/>
        <br/>
        Предположим, что у нас есть такой код:<br/>
        <br/>
        <pre><code class="javascript">console.log(y)
        y = 1
        console.log(y)
        console.log(greet('Mark'))
        
        function greet(name) {
            return 'Hello ' + name + '!'
        }
        
        var y
        </code></pre><br/>
        Получаем undefined, 1 и 'Hello Mark!'.<br/>
        <br/>
        Вот как выглядит фаза компиляции:<br/>
        <br/>
        <pre><code class="javascript">function greet(name) {
            return 'Hello ' + name + '!'
        }
        
        var y // присваивается undefined
        
        // ожидается завершение фазы компиляции
        
        // затем начинается фаза выполнения
        /*
        console.log(y)
        y = 1
        console.log(y)
        console.log(greet('Mark'))
        */
        </code></pre><br/>
        После завершения фазы компиляции начинается фаза выполнения, когда переменным присваиваются значения и вызываются функции.<br/>
        <br/>
        Дополнительно о Hoisting можно почитать <a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%9F%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5" rel="nofollow">здесь</a>.<br/>
        <br/>
        <a name="19"></a><h4>19. Что такое область видимости (Scope)?</h4><br/>
        Область видимости — это место, где (или откуда) мы имеем доступ к переменным или функциям. JS имеем три типа областей видимости: глобальная, функциональная и блочная (ES6).<br/>
        <br/>
        Глобальная область видимости — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости и доступны из любого места в коде.<br/>
        <br/>
        <pre><code class="javascript">// глобальное пространство имен
        var g = 'global'
        
        function globalFunc() {
            function innerFunc() {
                console.log(g) // имеет доступ к переменной g, поскольку она является глобальной
            }
            innerFunc()
        }
        </code></pre><br/>
        Функциональная область видимости (область видимости функции) — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции.<br/>
        <br/>
        <pre><code class="javascript">function myFavouriteFunc(a) {
            if (true) {
                var b = 'Hello ' + a
            }
            return b
        }
        myFavouriteFunc('World')
        
        console.log(a) // Uncaught ReferenceError: a is not defined
        console.log(b) // не выполнится
        </code></pre><br/>
        Блочная область видимости — переменные (объявленные с помощью ключевых слов «let» и «const») внутри блока ({ }), доступны только внутри него.<br/>
        <br/>
        <pre><code class="javascript">function testBlock() {
            if (true) {
                let z = 5
            }
            return z
        }
        
        testBlock() // Uncaught ReferenceError: z is not defined
        </code></pre><br/>
        Область видимости — это также набор правил, по которым осуществляется поиск переменной. Если переменной не существует в текущей области видимости, ее поиск производится выше, во внешней по отношению к текущей области видимости. Если и во внешней области видимости переменная отсутствует, ее поиск продолжается вплоть до глобальной области видимости. Если в глобальной области видимости переменная обнаружена, поиск прекращается, если нет — выбрасывается исключение. Поиск осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной. Это называется цепочкой областей видимости (Scope Chain).<br/>
        <br/>
        <pre><code class="javascript">// цепочка областей видимости
        // внутренняя область видимости -> внешняя область видимости -> глобальная область видимости
        
        // глобальная область видимости
        var variable1 = 'Comrades'
        var variable2 = 'Sayonara'
        
        function outer() {
            // внешняя область видимости
            var variable1 = 'World'
        
            function inner() {
                // внутренняя область видимости
                var variable2 = 'Hello'
                console.log(variable2 + ' ' + variable1)
            }
            inner()
        }
        outer()
        // в консоль выводится 'Hello World',
        // потому что variable2 = 'Hello' и variable1 = 'World' являются ближайшими
        // к внутренней области видимости переменными
        </code></pre><br/>
        <img src="https://habrastorage.org/r/w1560/webt/r6/07/q7/r607q7hehfjmuicf0_icntddk2s.png" data-src="https://habrastorage.org/webt/r6/07/q7/r607q7hehfjmuicf0_icntddk2s.png"/><br/>
        <br/>
        <a name="20"></a><h4>20. Что такое замыкание (Closures)?</h4><br/>
        Наверное, это самый сложный вопрос из списка. Я постараюсь объяснить, как я понимаю замыкание.<br/>
        <br/>
        По сути, замыкание — это способность функции во время создания запоминать ссылки на переменные и параметры, находящиеся в текущей области видимости, в области видимости родительской функции, в области видимости родителя родительской функции и так до глобальной области видимости с помощью цепочки областей видимости. Обычно область видимости определяется при создании функции.<br/>
        <br/>
        Примеры — отличный способ объяснить замыкание:<br/>
        <br/>
        <pre><code class="javascript">// глобальная область видимости
        var globalVar = 'abc'
        
        function a() {
            // область видимости функции
            console.log(globalVar)
        }
        
        a() // 'abc'
        // цепочка областей видимости
        // область видимости функции a -> глобальная область видимости
        </code></pre><br/>
        В данном примере, когда мы объявляем функцию, глобальная область видимости является частью замыкания.<br/>
        <br/>
        <img src="https://habrastorage.org/r/w1560/webt/10/ke/qa/10keqaosrww0rntbyei1gx9f_k0.png" data-src="https://habrastorage.org/webt/10/ke/qa/10keqaosrww0rntbyei1gx9f_k0.png"/><br/>
        <br/>
        Переменная «globalVar» не имеет значения на картинке, потому что ее значение может меняться в зависимости от того, где и когда будет вызвана функция. Но в примере выше globalVar будет иметь значение «abc».<br/>
        <br/>
        Теперь пример посложнее:<br/>
        <br/>
        <pre><code class="javascript">var globalVar = 'global'
        var outerVar = 'outer'
        
        function outerFunc(outerParam) {
            function innerFunc(innerParam) {
                console.log(globalVar, outerParam, innerParam)
            }
            return innerFunc
        }
        
        const x = outerFunc(outerVar)
        outerVar = 'outer-2'
        globalVar = 'guess'
        x('inner')
        </code></pre><br/>
        <img src="https://habrastorage.org/r/w1560/webt/ms/dv/wx/msdvwxdxp5s3l4cquxnqgkdtyr0.png" data-src="https://habrastorage.org/webt/ms/dv/wx/msdvwxdxp5s3l4cquxnqgkdtyr0.png"/><br/>
        <br/>
        В результате получаем «guess outer inner». Объяснение следующее: когда мы вызываем функцию outerFunc и присваиваем переменной «x» значение, возвращаемое функцией innerFunc, параметр «outerParam» равняется «outer». Несмотря на то, что мы присвоили переменной «outerVar» значение «outer-2», это произошло после вызова функции outerFunc, которая «успела» найти значение переменной «outerVar» в цепочке областей видимости, этим значением было «outer». Когда мы вызываем «x», которая ссылается на innerFunc, значением «innerParam» является «inner», потому что мы передаем это значение в качестве параметра при вызове «x». globalVar имеет значение «guess», потому что мы присвоили ей это значение перед вызовом «x».<br/>
        <br/>
        Пример неправильного понимания замыкания.<br/>
        <br/>
        <pre><code class="javascript">const arrFunc = []
        for (var i = 0; i &lt; 5; i++) {
            arrFunc.push(function() {
                return i
            })
        }
        console.log(i) // 5
        
        for (let i = 0; i &lt; arrFunc.length; i++) {
            console.log(arrFunc[i]()) // все 5
        }
        </code></pre><br/>
        Данный код работает не так, как ожидается. Объявление переменной с помощью ключевого слова «var» делает эту переменную глобальной. После добавления функций в массив «arrFunc» значением глобальной переменной «i» становится «5». Поэтому когда мы вызываем функцию, она возвращает значение глобальной переменной «i». Замыкание хранит ссылку на переменную, а не на ее значение во время создания. Эту проблему можно решить, используя IIFE или объявив переменную с помощью ключевого слова «let».<br/>
        <br/>
        Подробнее о замыкании можно почитать <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures" rel="nofollow">здесь</a> и <a href="https://learn.javascript.ru/closure" rel="nofollow">здесь</a>.<br/>
        <br/>
        <a name="21"></a><h4>21. Какие значения в JS являются ложными?</h4><br/>
        <pre><code class="javascript">const falsyValues = ['', 0, null, undefined, NaN, false]
        </code></pre><br/>
        Ложными являются значения, результатом преобразования которых в логическое значение является false.<br/>
        <br/>
        <a name="22"></a><h4>22. Как проверить, является ли значение ложным?</h4><br/>
        Следует использовать функцию Boolean или оператор "!!" (двойное отрицание).<br/>
        <br/>
        <a name="23"></a><h4>23. Для чего используется директива «use strict»?</h4><br/>
        «use strict» — это директива ES5, которая заставляет весь наш код или код отдельной функции выполняться в строгом режиме. Строгий режим вводит некоторые ограничения по написанию кода, тем самым позволяя избегать ошибок на ранних этапах.<br/>
        <br/>
        Вот какие ограничения накладывает строгий режим.<br/>
        <br/>
        Нельзя присваивать значения или обращаться к необъявленным переменным:<br/>
        <br/>
        <pre><code class="javascript">function returnY() {
            'use strict'
            y = 123
            return y
        }
        returnY() // Uncaught ReferenceError: y is not defined
        </code></pre><br/>
        Запрещено присваивать значения глобальный переменным, доступным только для чтения или записи:<br/>
        <br/>
        <pre><code class="javascript">'use strict'
        var NaN = NaN // Uncaught TypeError: Cannot assign to read only property 'NaN' of object '#&lt;Window>'
        var undefined = undefined
        var Infinity = 'and beyond'
        </code></pre><br/>
        Нельзя удалить «неудаляемое» свойство объекта:<br/>
        <br/>
        <pre><code class="javascript">'use strict'
        const obj = {}
        
        Object.defineProperties(obj, 'x', {
            value: 1
        })
        
        delete obj.x // Uncaught TypeError: Property description must be an object: x
        </code></pre><br/>
        Запрещено дублирование параметров:<br/>
        <br/>
        <pre><code class="javascript">'use strict'
        
        function someFunc(a, b, b, c) {} // Uncaught SyntaxError: Duplicate parameter name not allowed in this context
        </code></pre><br/>
        Нельзя создавать функции с помощью функции eval:<br/>
        <br/>
        <pre><code class="javascript">'use strict'
        
        eval('var x = 1')
        
        console.log(x) // Uncaught ReferenceError: x is not defined
        </code></pre><br/>
        Значением «this» по умолчанию является undefined:<br/>
        <br/>
        <pre><code class="javascript">'use strict'
        
        function showMeThis() {
            return this
        }
        
        showMeThis() // undefined
        </code></pre><br/>
        … и т.д.<br/>
        <br/>
        <a name="24"></a><h4>24. Какое значение имеет this?</h4><br/>
        Обычно this ссылается на значение объекта, который в данный момент выполняет или вызывает функцию. «В данный момент» означает, что значение this меняется в зависимости от контекста выполнения, от того места, где мы используем this.<br/>
        <br/>
        <pre><code class="javascript">const carDetails = {
            name: 'Ford Mustang',
            yearBought: 2005,
            getName() {
                return this.name
            }
            isRegistered: true
        }
        
        console.log(carDetails.getName()) // Ford Mustang
        </code></pre><br/>
        В данном случае метод getName возвращает this.name, а this ссылается на carDetails, объект, в котором выполняется getName, который является ее «владельцем».<br/>
        <br/>
        Добавим после console.log три строчки:<br/>
        <br/>
        <pre><code class="javascript">var name = 'Ford Ranger'
        var getCarName = carDetails.getName
        
        console.log(getCarName()) // Ford Ranger
        </code></pre><br/>
        Второй console.log выдает Ford Ranger, и это странно. Причина такого поведения заключается в том, что «владельцем» getCarName является объект window. Переменные, объявленные с помощью ключевого слова «var» в глобальной области видимости, записываются в свойства объекта window. this в глобальной области видимости ссылается на объект window (если речь не идет о строгом режиме).<br/>
        <br/>
        <pre><code class="javascript">console.log(getCarName === window.getCarName) // true
        console.log(getCarName === this.getCarName) // true
        </code></pre><br/>
        В этом примере this и window ссылаются на один объект.<br/>
        <br/>
        Одним из способов решения данной проблемы является использование методов call или apply:<br/>
        <br/>
        <pre><code class="javascript">console.log(getCarName.apply(carDetails)) // Ford Mustang
        console.log(getCarName.call(carDetails)) // Ford Mustang
        </code></pre><br/>
        Call и apply принимают в качестве первого аргумента объект, который будет являться значением this внутри функции.<br/>
        <br/>
        В IIFE, функциях, которые создаются в глобальном области видимости, анонимных функциях и внутренних функциях методов объекта значением this по умолчанию является объект window.<br/>
        <br/>
        <pre><code class="javascript">(function() {
            console.log(this)
        })() // window
        
        function iHateThis() {
            console.log(this)
        }
        iHateThis() // window
        
        const myFavouriteObj = {
            guessThis() {
                function getName() {
                    console.log(this.name)
                }
                getName()
            },
            name: 'Marko Polo',
            thisIsAnnoying(callback) {
                callback()
            }
        }
        
        myFavouriteObj.guessThis() // window
        myFavouriteObj.thisIsAnnoying(function() {
            console.log(this) // window
        })
        </code></pre><br/>
        Существует два способа получить «Marko Polo».<br/>
        <br/>
        Во-первых, мы можем сохранить значение this в переменной:<br/>
        <br/>
        <pre><code class="javascript">const myFavoriteObj = {
            guessThis() {
                const self = this // сохраняем значение this в переменной self
                function getName() {
                    console.log(self.name)
                }
                getName()
            },
            name: 'Marko Polo',
            thisIsAnnoying(callback) {
                callback()
            }
        }
        </code></pre><br/>
        Во-вторых, мы можем использовать стрелочную функцию:<br/>
        <br/>
        <pre><code class="javascript">const myFavoriteObj = {
            guessThis() {
                const getName = () => {
                    // копируем значение this из внешнего окружения
                    console.log(this.name)
                }
                getName()
            },
            name: 'Marko Polo',
            thisIsAnnoying(callback) {
                callback()
            }
        }
        </code></pre><br/>
        Стрелочные функции не имеют собственного значения this. Они копируют значение this из внешнего лексического окружения.<br/>
        <br/>
        <a name="25"></a><h4>25. Что такое прототип объекта?</h4><br/>
        В двух словах, прототип — это план (схема или проект) объекта. Он используется как запасной вариант для свойств и методов, существующих в данном объекте. Это также один из способов обмена свойствами и функциональностью между объектами. Это основная концепция прототипного наследования в JS.<br/>
        <br/>
        <pre><code class="javascript">const o = {}
        console.log(o.toString()) // [object Object]
        </code></pre><br/>
        Несмотря на то, что объект «о» не имеет свойства toString, обращение к этому свойству не вызывает ошибки. Если определенного свойства нет в объекте, его поиск осуществляется сначала в прототипе объекта, затем в прототипе прототипа объекта и так до тех пор, пока свойство не будет найдено. Это называется цепочкой прототипов. На вершине цепочки прототипов находится Object.prototype.<br/>
        <br/>
        <pre><code class="javascript">console.log(o.toString === Object.prototype.toString) // true
        </code></pre><br/>
        Подробнее о прототипах и наследовании можно почитать <a href="https://learn.javascript.ru/prototype-inheritance" rel="nofollow">здесь</a> и <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" rel="nofollow">здесь</a>.<br/>
        <br/>
        <a name="26"></a><h4>26. Что такое IIFE?</h4><br/>
        IIFE или Immediately Invoked Function Expression — это функция, которая вызывается или выполняется сразу же после создания или объявления. Для создания IIFE необходимо обернуть функцию в круглые скобки (оператор группировки), превратив ее в выражение, и затем вызвать ее с помощью еще одних круглых скобок. Это выглядит так: (function(){})().<br/>
        <br/>
        <pre><code class="javascript">(function( ) { }( ))
        
        (function( ) { })( )
        
        (function named(params) { })( )
        
        (( ) => { })
        
        (function(global) { })(window)
        
        const utility = (function( ) {
            return {
                // утилиты
            }
        })
        </code></pre><br/>
        Все эти примеры являются валидными. Предпоследний пример показывает, что мы можем передавать параметры в IIFE. Последний пример показывает, что мы можем сохранить результат IIFE в переменной.<br/>
        <br/>
        Лучшее использование IIFE — это выполнение функций настройки инициализации и предотвращение конфликтов имен с другими переменными в глобальной области видимости (загрязнение глобального пространства имен). Приведем пример.<br/>
        <br/>
        <pre><code class="javascript">&lt;script src="https://cdnurl.com/somelibrary.js">&lt;/script>
        </code></pre><br/>
        У нас есть ссылка на библиотеку somelibrary.js, которая предоставляет некоторые глобальные функции, которые мы можем использовать в нашем коде, но в этой библиотеке есть два метода, createGraph и drawGraph, которые мы не используем, потому что они содержат ошибки. И мы хотим реализовать эти функции самостоятельно.<br/>
        <br/>
        Одним из способов решить данную проблему является изменение структуры наших скриптов:<br/>
        <br/>
        <pre><code class="javascript">&lt;script src="https://cdnurl.com/somelibrary.js">&lt;/script>
        &lt;script>
            function createGraph() {
                // код
            }
        
            function drawGraph() {
                // код
            }
        &lt;/script>
        </code></pre><br/>
        Таким образом, мы переопределяем методы, предоставляемые библиотекой.<br/>
        <br/>
        Вторым способом является изменение имен наших функций:<br/>
        <br/>
        <pre><code class="javascript">&lt;script src="https://cdnurl.com/somelibrary.js">&lt;/script>
        &lt;script>
            function myCreateGraph() {
                // код
            }
        
            function myDrawGraph() {
                // код
            }
        &lt;/script>
        </code></pre><br/>
        Третий способ — использование IIFE:<br/>
        <br/>
        <pre><code class="javascript">&lt;script>
            const graphUtility = (function() {
                function createGraph() {
                    // код
                }
        
                function drawGraph() {
                    // код
                }
                return {
                    createGraph,
                    drawGraph
                }
            })
        &lt;/script>
        </code></pre><br/>
        В этом примере мы создаем служебную переменную, которая содержит результат IIFE, возвращающий объект, содержащий методы createGraph и drawGraph.<br/>
        <br/>
        Вот еще одна проблема, которую можно решить с помощью IIFE:<br/>
        <br/>
        <pre><code class="javascript">val li = document.querySelectorAll('.list-group > li')
        for (var i - 0, len = li.length; i &lt; len; i++) {
            li[i].addEventListener('click', function(e) {
                console.log(i)
            })
        }
        </code></pre><br/>
        Допустим, у нас есть элемент «ul» с классом «list-group», содержащий 5 дочерних элементов «li». И мы хотим выводить в консоль значение «i» при клике по отдельному «li». Однако вместо этого в консоль всегда выводится 5. Виной всему замыкание.<br/>
        <br/>
        Одним из решений является IIFE:<br/>
        <br/>
        <pre><code class="javascript">var li = document.querySelectorAll('.list-group > li')
        for (var i = 0, len = li.length; i &lt; len; i++) {
            (function(currentIndex) {
                li[currentIndex].addEventListener('click', function(e) {
                    console.log(currentIndex)
                })
            })(i)
        }
        </code></pre><br/>
        Причина, по которой этот код работает, как задумано, состоит в том, что IIFE создает новую область видимости на каждой итерации, и мы записываем значение «i» в currentIndex.<br/>
        <br/>
        <a name="27"></a><h4>27. Для чего используется метод Function.prototype.apply?</h4><br/>
        Apply используется для привязки определенного объекта к значению this вызываемой функции.<br/>
        <br/>
        <pre><code class="javascript">const details = {
            message: 'Hello World!'
        }
        
        function getMessage() {
            return this.message
        }
        
        getMessage.apply(details) // Hello World!
        </code></pre><br/>
        Этот метод похож на Function.prototype.call. Единственное отличие состоит в том, что в apply аргументы передаются в виде массива.<br/>
        <br/>
        <pre><code class="javascript">const person = {
            name: 'Marko Polo'
        }
        
        function greeting(greetingMessage) {
            return `${greetingMessage} ${this.name}`
        }
        
        greeting.apply(person, ['Hello']) // Hello Marko Polo
        </code></pre><br/>
        <a name="28"></a><h4>28. Для чего используется метод Function.prototype.call?</h4><br/>
        Call используется для привязки определенного объекта к значению this вызываемой функции.<br/>
        <br/>
        <pre><code class="javascript">const details = {
            message: 'Hello World!'
        };
        
        function getMessage() {
            return this.message;
        }
        
        getMessage.call(details); // Hello World!
        </code></pre><br/>
        Этот метод похож на Function.prototype.apply. Отличие состоит в том, что в call аргументы передаются через запятую.<br/>
        <br/>
        <pre><code class="javascript">const person = {
            name: 'Marko Polo'
        };
        
        function greeting(greetingMessage) {
            return `${greetingMessage} ${this.name}`;
        }
        
        greeting.call(person, 'Hello'); // Hello Marko Polo
        </code></pre><br/>
        <a name="29"></a><h4>29. В чем разница между методами call и apply?</h4><br/>
        Отличие между call и apply состоит в том, как мы передаем аргументы в вызываемой функции. В apply аргументы передаются в виде массива, в call — через запятую.<br/>
        <br/>
        <pre><code class="javascript">const obj1 = {
            result: 0
        }
        
        const obj2 = {
            result: 0
        }
        
        function reduceAdd() {
            let result = 0
            for (let i = 0, len = arguments.length; i &lt; len; i++) {
                result += arguments[i]
            }
            this.result = result
        }
        
        reduceAdd.apply(obj1, [1, 2, 3, 4, 5]) // 15
        reduceAdd.call(obj2, 1, 2, 3, 4, 5) // 15
        </code></pre><br/>
        <a name="30"></a><h4>30. Для чего используется метод Function.prototype.bind?</h4><br/>
        Bind возвращает новую функцию, значением this которой является объект, указанный в качестве первого параметра. В отличие от bind, call и apply сразу же вызывают функцию.<br/>
        <br/>
        <pre><code class="javascript">import React from 'react'
        
        class MyComponent extends React.Component {
            constructor(props) {
                super(props)
                this.state = {
                    value: ''
                }
                this.handleChange = this.handleChange.bind(this)
                // привязываем метод handleChange к компоненту MyComponent
            }
        
            handleChange(e) {
                // код
            }
        
            render() {
                return ( &lt; >
                    &lt;
                    input type = {
                        this.props.type
                    }
                    value = {
                        this.state.value
                    }
                    onChange = {
                        this.handleChange
                    }
                    /> &lt;/ >
                )
            }
        }
        </code></pre><br/>
        <a name="31"></a><h4>31. Что такое функциональное программирование и какие особенности JS позволяют говорить о нем как о функциональном языке программирования?</h4><br/>
        Функциональное программирование — это декларативная концепция программирования или образец (паттерн) того, как строятся приложения, как используются функции, содержащие выражения, которые вычисляют значения без изменения аргументов, которые им передаются.<br/>
        <br/>
        Объект Array содержит методы map, filter и reduce, которые являются самыми известными функциями в мире функционального программирования из-за их полезности, а также потому, что они не изменяют массив, что делает эти функции «чистыми». Также в JS имеются замыкание и функции высшего порядка, которые являются характеристиками функционального языка программирования.<br/>
        <br/>
        Метод map возвращает новый массив с результатами вызова callback для каждого элемента массива:<br/>
        <br/>
        <pre><code class="javascript">const words = ['Functional', 'Procedural', 'Object-Oriented']
        
        const wordsLength = words.map(word => word.length)
        </code></pre><br/>
        Метод filter создает новый массив со всеми элементами, которые удовлетворяют условию, указанному в callback:<br/>
        <br/>
        <pre><code class="javascript">const data = {
            {
                name: 'Mark',
                isRegistered: true
            } {
                name: 'Mary',
                isRegistered: false
            } {
                name: 'Mae',
                isRegistered: true
            }
        }
        
        const registeredUsers = data.filter(user => user.isRegistered)
        </code></pre><br/>
        Метод reduce выполняет callback один раз для каждого элемента массива, за исключением пустот, принимая четыре аргумента: начальное значение (или значение от предыдущего callback), значение текущего элемента, текущий индекс и итерируемый массив:<br/>
        <br/>
        <pre><code class="javascript">const strs = ['I', ' ', 'am', ' ', 'Iron', ' ', 'Man']
        
        const result = strs.reduce((acc, currentStr) => acc + str, '')
        </code></pre><br/>
        <a name="32"></a><h4>32. Что такое функции высшего порядка (Higher Order Functions)?</h4><br/>
        Функция высшего порядка — это функция, возвращающая другую функцию или принимающая другую функцию в качестве аргумента.<br/>
        <br/>
        <pre><code class="javascript">function higherOrderFunction(param, callback) {
            return callback(param)
        }
        </code></pre><br/>
        <a name="33"></a><h4>33. Почему функции в JS называют объектами первого класса (First-class Objects)?</h4><br/>
        Функции называют объектами первого класса, потому что они обрабатываются также, как и любое другое значение в JS. Они могут присваиваться переменным, быть свойством объекта (методом), элементом массива, аргументом другой функции, значением, возвращаемым функцией. Единственным отличием функции от любого другого значения в JS является то, что функция может быть выполнена или вызвана.<br/>
        <br/>
        <a name="34"></a><h4>34. Как бы Вы реализовали метод Array.prototype.map?</h4><br/>
        <pre><code class="javascript">function map(arr, mapCallback) {
            // проверяем переданные параметры
            if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== 'function') {
                return []
            } else {
                let result = []
                // мы создаем массив с результатами при каждом вызове функции
                // поскольку мы не хотим менять оригинальный массив
                for (let i = 0, len = arr.length; i &lt; len; i++) {
                    result.push(mapCallback(arr[i], i, arr))
                    // помещаем результаты mapCallback в result
                }
                return result
            }
        }
        </code></pre><br/>
        Метод map создает новый массив с результатом вызова указанной функции для каждого элемента массива.<br/>
        <br/>
        <a name="35"></a><h4>35. Как бы Вы реализовали метод Array.prototype.filter?</h4><br/>
        <pre><code class="javascript">function filter(arr, filterCallback) {
            // проверяем передаваемые параметры
            if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== 'function') {
                return []
            } else {
                let result = []
                // ...
                for (let i = 0, len = arr.length; i &lt; len; i++) {
                    // определяем соответствие возвращаемого результата заданному условию
                    if (filterCallback(arr[i], i, arr)) {
                        // помещаем значение, прошедшее фильтр, в result
                        result.push(arr[i])
                    }
                }
                return result
            }
        }
        </code></pre><br/>
        Метод filter создает новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.<br/>
        <br/>
        <a name="36"></a><h4>36. Как бы Вы реализовали метод Array.prototype.reduce?</h4><br/>
        <pre><code class="javascript">function reduce(arr, reduceCallbak, initialValue) {
            // ..
            if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== 'function') {
                return []
            } else {
                // если в функцию не было передано значения initialValue, то
                let hasInitialValue = initialValue !== undefined
                let value = hasInitialValue ? initialValue : arr[0]
                // мы будем использовать первый элемент initialValue
        
                // затем мы перебираем массив, начиная с 1, если в функцию не передавалось значения initialValue, либо с 0, если значение было передано
                for (let i = hasInitialValue ? 0 : 1, len = arr.length; i &lt; len; i++) {
                    // затем на каждой итерации мы присваиваем результат вызова reduceCallback переменной
                    value = reduceCallback(value, arr[i], i, arr)
                }
                return value
            }
        }
        </code></pre><br/>
        Метод reduce применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение.<br/>
        <br/>
        <a name="37"></a><h4>37. Что такое объект arguments?</h4><br/>
        Arguments — это коллекция аргументов, передаваемых функции. Это объект, подобный массиву, у него есть свойство length, мы можем получить доступ к определенному значению с помощью arguments[i], но у него отсутствуют методы forEach, reduce, filter и map. Он позволяет узнать количество параметров функции.<br/>
        <br/>
        Преобразовать arguments в массив можно с помощью Array.prototype.slice:<br/>
        <br/>
        <pre><code class="javascript">Array.prototype.slice.call(arguments)
        </code></pre><br/>
        Запомните: в стрелочных функциях объект arguments не работает.<br/>
        <br/>
        <pre><code class="javascript">function one() {
            return arguments
        }
        const two = function() {
            return arguments
        }
        const three = function three({
            return arguments
        })
        const four = () => arguments
        
        four() // arguments is not defined
        </code></pre><br/>
        Вызов функции four приводит к ошибке ReferenceError: arguments is not defined. Эту проблему можно решить с помощью оператора rest:<br/>
        <br/>
        <pre><code class="javascript">const four = (...args) => args
        </code></pre><br/>
        Это автоматически поместит все параметры в массив.<br/>
        <br/>
        <a name="38"></a><h4>38. Как создать объект, не имеющий прототипа?</h4><br/>
        Это можно сделать с помощью Object.create:<br/>
        <br/>
        <pre><code class="javascript">const o1 = {}
        console.log(o1.toString) // [object Object]
        
        const o2 = Object.create(null) // в качестве первого параметра методу Object-create передается объект-прототип
        // нам не нужен объект-прототип, поэтому передаем null
        console.log(o2.toString) // o2.toString is not a function
        </code></pre><br/>
        <a name="39"></a><h4>39. Почему в представленном коде переменная b становится глобальной при вызове функции?</h4><br/>
        <br/>
        <pre><code class="javascript">function myFunc(){
            let a = b = 0
        }
        myFunc()
        </code></pre><br/>
        Так происходит, потому что оператор присваивания ("=") имеет правостороннюю ассоциативность, т.е. присваивает значения справа налево. Поэтому код принимает следующий вид:<br/>
        <br/>
        <pre><code class="javascript">function myFunc(){
            let a = (b = 0)
        }
        myFunc()
        </code></pre><br/>
        Сначала значение 0 присваивается переменной «b», которая не объявлена. Движок JS делает ее глобальной. Возвращаемое выражением b = 0 значение (0) затем присваивается локальной переменной «a».<br/>
        <br/>
        Эту проблему можно решить сначала объявив локальные переменные, а затем присвоив им значения:<br/>
        <br/>
        <pre><code class="javascript">function myFunc(){
            let a, b
            a = b = 0
        }
        myFunc()
        </code></pre><br/>
        <a name="40"></a><h4>40. Что такое ECMAScript?</h4><br/>
        ECMAScript — это спецификация, стандарт скриптовых языков программирования, он является основой JS, поэтому любые изменения ECMAScript отражаются на JS.<br/>
        <br/>
        Последний вариант спецификации ECMA-262 можно посмотреть <a href="https://www.ecma-international.org/publications/standards/Ecma-262.htm" rel="nofollow">здесь</a>.<br/>
        <br/>
        <a name="41"></a><h4>41. Что нового привнес в JS стандарт ES6 или ECMAScript2015?</h4><br/>
        <ul>
        <li>Стрелочные функции (Arrow Functions).</li>
        <li>Классы (Classes).</li>
        <li>Шаблонные строки (Template Strings).</li>
        <li>Расширенные объектные литералы (Enhanced Object literals).</li>
        <li>Деструктуризация (Object Destructuring).</li>
        <li>Промисы (Promises).</li>
        <li>Генераторы (Generators).</li>
        <li>Модули (Modules).</li>
        <li>Symbol.</li>
        <li>Прокси (Proxies).</li>
        <li>Множества (Sets).</li>
        <li>Параметры по умолчанию.</li>
        <li>Операторы rest и spread.</li>
        <li>Блочная область видимости (ключевые слова «let» и «const»).</li>
        </ul><br/>
        <a name="42"></a><h4>42. В чем разница между ключевыми словами «var», «let» и «const»?</h4><br/>
        Переменные, объявленные с помощью ключевого слова «var», являются глобальными. Это означает, что они доступны из любого места в коде:<br/>
        <br/>
        <pre><code class="javascript">function giveMeX(showX){
            if(showX){
                var x = 5
            }
            return x
        }
        
        console.log(giveMeX(false))
        console.log(giveMeX(true))
        </code></pre><br/>
        Результатом первого console.log будет undefined, второго — 5. Мы имеем доступ к переменной «x» из-за ее всплытия в глобальную область видимости. Код из примера выше интерпретируется следующим образом:<br/>
        <br/>
        <pre><code class="javascript">function giveMeX(showX){
            var x // имеет значение undefined
            if(showX){
                x = 5
            }
            return x
        }
        </code></pre><br/>
        Результатом первого console.log является undefined, поскольку объявленные переменные, которым не присвоено значения, имеют значение undefined по умолчанию.<br/>
        <br/>
        Переменные, объявленные с помощью ключевых слов «let» и «const» имеют блочную область видимости. Это означает, что они доступны только внутри блока ({ }):<br/>
        <br/>
        <pre><code class="javascript">function giveMeX(showX){
            if(showX){
                let x = 5
            }
            return x
        }
        
        function giveMeY(showY){
            if(showY){
                let y = 5
            }
            return y
        }
        </code></pre><br/>
        Вызов этих функций с параметром false приведет к ошибке ReferenceError, потому что к переменным «x» и «y» нет доступа снаружи блока и их значения не возвращаются (не всплывают).<br/>
        <br/>
        Разница между «let» и «const» состоит в том, что в первом случае мы может менять значение переменной, а во втором — нет (константа). При этом, мы можем менять значение свойства объекта, объявленного с помощью const, но не само свойство (переменную).<br/>
        <br/>
        <a name="43"></a><h4>43. Что такое стрелочные функции (Arrow Functions)?</h4><br/>
        Стрелочная функция — это относительно новый способ создания функций в JS. Стрелочные функции создаются быстрее и имеют более читаемый синтаксис, чем функциональные выражения. В стрелочных функциях опускается слово «function»:<br/>
        <br/>
        <pre><code class="javascript">// ES5
        var getCurrentDate = function(){
            return new Date()
        }
        
        // ES6
        const getCurrentDate = () => new Date()
        </code></pre><br/>
        В функциональном выражении мы используем ключевое слово «return» для возврата значения. В стрелочной функции мы этого не делаем, поскольку стрелочные функции неявно возвращают значения при условии, что мы возвращаем одно выражение или значение:<br/>
        <br/>
        <pre><code class="javascript">// ES5
        function greet(name){
            return 'Hello ' + name + '!' 
        }
        
        // ES6
        const greet = (name) => `Hello ${name}`
        const greet2 = name = > `Hello ${name}`
        </code></pre><br/>
        Мы также можем передавать параметры стрелочным функциям. Если мы передаем один параметр, его можно не оборачивать в круглые скобки:<br/>
        <br/>
        <pre><code class="javascript">const getArgs = () => arguments
        
        const getArgs2 = (...rest) => rest
        </code></pre><br/>
        У стрелочных функций нет доступа к объекту arguments. Поэтому вызов первой функции приведет к ошибке. Для получения параметров, переданных функции, мы можем использовать оператор rest.<br/>
        <br/>
        <pre><code class="javascript">const data = {
            result: 0
            nums: [1,2,3,4,5]
            computeResult(){
                // this ссылается на объект data
                const addAll = () => {
                // стрелочные функции копируют значение this из лексического окружения
                return this.nums.reduce((total, cur) => total + cur, 0)
                }
            this.result = addAll()
            }
        }
        </code></pre><br/>
        <a name="44"></a><h4>44. Что такое классы (Classes)?</h4><br/>
        Классы — это относительно новый способ написания функций-конструкторов в JS. Это синтаксический сахар для функций-конструкторов. В основе классов лежат те же прототипы и прототипное наследование:<br/>
        <br/>
        <pre><code class="javascript">// ES5
        function Person(firstName, lastName, age, address){
            this.firstName = firstName
            this.lastName = lastName
            this.age = age
            this.address = address
        }
        
        Person.self = function(){
            return this
        }
        
        Person.prototype.toString = function(){
            return '[object Person]'
        }
        
        Person.prototype.getFullName = function(){
            return this.firstName + ' ' + this.lastName
        }
        
        // ES6
        class Person{
            constructor(firstName, lastName, age, address){
                this.firstName = firstName
                this.lastName = lastName
                this.age = age
                this.address = address
            }
        
            static self(){
                return this
            }
        
            toString(){
                return '[object Person]'
            }
        
            getFullName(){
                return `${this.firstName} ${this.lastName}`
            }
        }
        </code></pre><br/>
        Переопределение методов и наследование от другого класса:<br/>
        <br/>
        <pre><code class="javascript">// ES5
        Employee.prototype = Object.create(Person.prototype)
        
        function Employee(firstName, lastName, age, address, jobTitle, yearStarted){
            Person.call(this, firstName, lastName, age, address)
            this.jobTitle = jobTitle
            this.yearStarted = yearStarted
        }
        
        Employee.prototype.describe = function(){
            return `I am ${this.getFullName()} and I have a position of #{this.jobTitle} and I started at ${this.yearStarted}}`
        }
        
        Employee.prototype.toString = function(){
            return '[object Employee]'
        }
        
        // ES6
        class Employee extends Person{ // наследуемся от Person
            constructor(firstName, lastName, age, address, jobTitle, yearStarted){
                super(firstName, lastName, age, address)
                this.jobTitle = jobTitle
                this.yearStarted = yearStarted
            }
        
            describe(){
               return `I am ${this.getFullName()} and I have a position of #{this.jobTitle} and I started at ${this.yearStarted}}` 
            }
        
            toString(){ // переопределяем метод toString класса Person
                return '[object Employee]'
            }
        }
        </code></pre><br/>
        Как узнать об использовании прототипов?<br/>
        <br/>
        <pre><code class="javascript">class Something{ }
        
        function AnotherSomething(){ }
        
        const as = new AnotherSomething()
        const s = new Something()
        
        console.log(typeof Something) // function
        console.log(typeof AnotherSomething) // function
        console.log(as.toString()) // [object Object]
        console.log(a.toString()) // [object Object]
        console.log(as.toString === Object.prototype.toString)
        console.log(a.toString === Object.prototype.toString)
        // в обоих случаях получаем true
        // Object.prototype находится на вершине цепочки прототипов
        // Something и AnotherSomething наследуют от Object.prototype
        </code></pre><br/>
        <a name="45"></a><h4>45. Что такое шаблонные литералы (Template Literals)?</h4><br/>
        Шаблонные литералы — относительно новый способ создания строк в JS. Шаблонные литералы создаются с помощью двойных обратных кавычек (``):<br/>
        <br/>
        <pre><code class="javascript">// ES5
        var greet = 'Hi I\'m Mark'
        
        // ES6
        let greet = `Hi I'm Mark`
        </code></pre><br/>
        В шаблонных литералах нам не нужно экранировать одинарные кавычки.<br/>
        <pre><code class="javascript">// ES5
        var lastWords = '\n'
            + ' I \n'
            + ' am \n'
            + 'Iron Man \n'
        
        // ES6
        let lastWords = `
            I
            am
            Iron Man
        `
        </code></pre><br/>
        В ES6 нам не нужно использовать управляющую последовательность "\n" для перевода строки.<br/>
        <br/>
        <pre><code class="javascript">// ES5
        function greet(name){
            return 'Hello ' + name + '!'
        }
        
        // ES6
        function greet(name){
            return `Hello ${name}!`
        }
        </code></pre><br/>
        В ES6 нам не нужно использовать конкатенацию строк для объединения текста с переменной: мы можем использовать выражение ${expr} для получения значения переменной.<br/>
        <br/>
        <a name="46"></a><h4>46. Что такое деструктуризация объекта (Object Destructuring)?</h4><br/>
        Деструктуризация — относительно новый способ получения (извлечения) значений объекта или массива.<br/>
        <br/>
        Допустим, у нас есть такой объект:<br/>
        <br/>
        <pre><code class="javascript">const employee = {
            firstName: 'Marko',
            lastName: 'Polo',
            position: 'Software Developer',
            yearHired: 2017
        }
        </code></pre><br/>
        Раньше для получения свойств объекта мы создавали переменные для каждого свойства. Это было очень скучно и сильно раздражало:<br/>
        <br/>
        <pre><code class="javascript">var firstName = employee.firstName
        var lastName = employee.lastName
        var position = employee.position
        var yearHired = employee.yearHired
        </code></pre><br/>
        Использование деструктуризации позволяет сделать код чище и отнимает меньше времени. Синтаксис деструктуризации следующий: заключаем свойства объекта, которые хотим получить, в фигурные скобки ({ }), а если речь идет о массиве — в квадратные скобки ([ ]):<br/>
        <br/>
        <pre><code class="javascript">let { firstName, lastName, position, yearHired } = employee
        </code></pre><br/>
        Для изменения имени переменной следует использовать «propertyName: newName»:<br/>
        <br/>
        <pre><code class="javascript">let { firstName: fName, lastName: lName, position, yearHired } = employee
        </code></pre><br/>
        Для присвоения переменным значения по умолчанию следует использовать «propertyName = 'defaultValue'»:<br/>
        <br/>
        <pre><code class="javascript">let { firstName = 'Mark', lastName: lName, position, yearHired } = employee
        </code></pre><br/>
        <a name="47"></a><h4>47. Что такое модули (Modules)?</h4><br/>
        Модули позволяют объединять (использовать) код из разных файлов и избавляют нас от необходимости держать весь код в одном большом файле. До появления модулей в JS существовало две популярные системы модулей для поддержки кода:<br/>
        <br/>
        <ul>
        <li>CommonJS — Nodejs</li>
        <li>AMD (AsyncronousModuleDefinition) — Browsers</li>
        </ul><br/>
        Синтаксис модулей очень простой: мы используем import для импорта функциональности или значений из другого файла или файлов и export для экспорта.<br/>
        <br/>
        Экспорт функциональности в другой файл (именной экспорт):<br/>
        <br/>
        <pre><code class="javascript">// ES5 CommonJS - helpers.js
        exports.isNull = function(val){
            return val === null
        }
        
        exports.isUndefined = function(val){
            return val === undefined
        }
        
        exports.isNullOrUndefined = function(val){
            return exports.isNull(val) || exports.isUndefined(val)
        }
        
        // ES6 модули
        export function isNull(val){
            return val === null;
        }
        
        export function isUndefined(val) {
            return val === undefined;
        }
        
        export function isNullOrUndefined(val) {
            return isNull(val) || isUndefined(val);
        }
        </code></pre><br/>
        Импорт функциональности в другой файл:<br/>
        <br/>
        <pre><code class="javascript">// ES5 CommonJS - index.js
        const helpers = require('./helpers.js')
        const isNull = helpers.isNull
        const isUndefined = helpers.isUndefined
        const isNullOrUndefined = helpers.isNullOrUndefined
        
        // либо с помощью деструктуризации
        const { isNull, isUndefined, isNullOrUndefined } = require('./helpers.js')
        
        // ES6 модули
        import * as helpers from './helpers.js' // helpers - это объект
        
        // либо
        import { isNull, isUndefined, isNullOrUndefined as isValid} from './helpers.js' // используем "as" для переименовывания
        </code></pre><br/>
        Экспорт по умолчанию:<br/>
        <br/>
        <pre><code class="javascript">// ES5 CommonJS - index.js
        class Helpers {
            static isNull(val){
                return val === null
            }
        
            static isUndefined(val){
                return val === undefined
            }
        
            static isNullOrUndefined(val){
                return this.isNull(val) || this.isUndefined(val)
            }
        }
        
        module.exports = Helpers
        
        // ES6 модули
        class Helpers {
            static isNull(val){
                return val === null
            }
        
            static isUndefined(val){
                return val === undefined
            }
        
            static isNullOrUndefined(val){
                return this.isNull(val) || this.isUndefined(val)
            }
        }
        
        export default Helpers
        </code></pre><br/>
        Импорт:<br/>
        <br/>
        <pre><code class="javascript">// ES5 CommonJS - index.js
        const Helpers = require('./helpers.js')
        console.log(Helpers.isNull(null))
        
        // ES6 модули
        import Helpers from './helpers.js'
        console.log(Helpers.isNull(null))
        </code></pre><br/>
        Это базовое использование модулей. Я не стал вдаваться в подробности, поскольку мой пост и без того получается слишком большим.<br/>
        <br/>
        <a name="48"></a><h4>48. Что такое объект Set?</h4><br/>
        Объект Set позволяет хранить уникальные значения, примитивы и ссылки на объекты. Еще раз: в Set можно добавлять только уникальные значения. Он проверяет хранящиеся в нем значения с помощью алгоритма SameZeroValue.<br/>
        <br/>
        Экземпляр Set создается с помощью конструктора Set. Мы также можем передать ему некоторые значения при создании:<br/>
        <br/>
        <pre><code class="javascript">const set1 = new Set()
        const set2 = new Set(['a','b','c','d','d','e']) // вторая "d" не добавится
        </code></pre><br/>
        Мы можем добавлять значения в Set, используя метод add. Поскольку метод add является возвращаемым, мы может использовать цепочку вызовов:<br/>
        <br/>
        <pre><code class="javascript">set2.add('f')
        set2.add('g').add('h').add('i').add('j').add('k').add('k') // вторая "k" не добавится
        </code></pre><br/>
        Мы можем удалять значения из Set, используя метод delete:<br/>
        <br/>
        <pre><code class="javascript">set2.delete('k') // true
        set2.delete('z') // false, потому что в set2 нет такого значения
        </code></pre><br/>
        Мы можем проверить наличие свойства в Set, используя метод has:<br/>
        <br/>
        <pre><code class="javascript">set2.has('a') // true
        set2.has('z') // false
        </code></pre><br/>
        Для получения длины Set используется метод size:<br/>
        <br/>
        <pre><code class="javascript">set2.size // 10
        </code></pre><br/>
        Метод clear очищает Set:<br/>
        <br/>
        <pre><code class="javascript">set2.clear() // пусто
        </code></pre><br/>
        Мы можем использовать Set для удаления повторяющихся значений в массиве:<br/>
        <br/>
        <pre><code class="javascript">const nums = [1,2,3,4,5,6,6,7,8,8,5]
        const uniqNums = [...new Set(nums)] // [1,2,3,4,5,6,7,8]
        </code></pre><br/>
        <a name="49"></a><h4>49. Что такое функция обратного вызова (Callback Function)?</h4><br/>
        Функция обратного вызова — это функция, вызов которой отложен на будущее (происходит при некоторых условиях, например, при наступлении события).<br/>
        <br/>
        <pre><code class="javascript">const btnAdd = document.getElementById('btnAdd')
        
        btnAdd.addEventListener('click', function clickCallback(e)){
            // делаем нечто полезное
        }
        </code></pre><br/>
        В примере мы ждем события «клик» на элементе с идентификатором «btnAdd». По клику вызывается функция clickCallback. Функция обратного вызова добавляет некоторый функционал данным или событию. Методам reduce, filter и map в качестве второго аргумента передается функция обратного вызова. Хорошей аналогией callback является следующая ситуация: Вы звоните кому-то, он не отвечает, Вы оставляете ему сообщение и ждете, когда он перезвонит. Звонок или сообщение — это событие или данные, а callback — это ожидание (предвосхищение) встречного звонка.<br/>
        <br/>
        <a name="50"></a><h4>50. Что такое промисы (Promises)?</h4><br/>
        Промисы — это один из приемов работы с асинхронным кодом в JS. Они возвращают результат асинхронной операции. Промисы были придуманы для решения проблемы так называемого «ада функций обратного вызова».<br/>
        <br/>
        <pre><code class="javascript">fs.readFile('somefile.txt', function(e, data){
            if(e){
                console.log(e)
            }
            console.log(data)
        })
        </code></pre><br/>
        Проблемы при таком подходе начинаются, когда нам необходимо добавить еще одну асинхронную операцию в первую (внутрь первой), затем еще одну и т.д. В результате мы получаем беспорядочный и нечитаемый код:<br/>
        <br/>
        <pre><code class="javascript">fs.readFile('somefile.txt', function(e,data){
            // код
            fs.readFile('directory', function(e, files){
                // код
                fs.mkdir('directory', function(e){
                    // код
                })
            })
        })
        </code></pre><br/>
        А вот как это выглядит с промисами:<br/>
        <br/>
        <pre><code class="javascript">promReadFile('file/path')
        .then(data => {
            return promReaddir('directory')
        })
        .then(data => {
            return promMkdir('directory')
        })
        .catch(e => {
            console.error(e)
        })
        </code></pre><br/>
        У промиса есть четыре состояния:<br/>
        <br/>
        <ul>
        <li>Ожидание — начальное состояние промиса. Результата промиса неизвестен, поскольку операция не завершена.</li>
        <li>Выполнено — асинхронная операция выполнена, имеется результат.</li>
        <li>Отклонено — асинхронная операция не выполнена, имеется причина.</li>
        <li>Завершено — выполнено или отклонено.</li>
        </ul><br/>
        В качестве параметров конструктор промиса принимает resolve и reject. В resolve записывается результат выполнения операции, в reject — причина невыполнения операции. Результат может быть обработан в методе .then, ошибка — в методе .catch. Метод .then также возвращает промис, поэтому мы можем использовать цепочку, состоящую из нескольких .then.<br/>
        <br/>
        <pre><code class="javascript">const myPromiseAsync = (...args) => {
            return new Promise((resolve, reject) => {
                doSomeAsync(...args, (error, data) => {
                    if(error){
                        reject(error)
                    } else{
                        resolve(data)
                    }
                })
            })
        }
        
        myPromiseAsync()
        .then(result => {
            console.log(result)
        })
        .catch(reason => {
            console.error(reason)
        })
        </code></pre><br/>
        Мы можем создать вспомогательную функцию для преобразования асинхронной операции с callback в промис. Она будет работать наподобие util из Node.js («промисификация»):<br/>
        <br/>
        <pre><code class="javascript">const toPromise = (asyncFuncWithCallback) => {
            return (...args) => {
                return new Promise((res, rej) => {
                    asyncFuncWithCallback(...args, (e, result) => {
                        return e ? rej(e) : res(result)
                    })
                })
            }
        }
        
        const promiseReadFile = toPromise(fs.readFile)
        
        promiseReadFile('file/path')
        .then((data) => {
            console.log(data)
        })
        .catch(e => console.error(e))
        </code></pre><br/>
        Подробнее о промисах можно почитать <a href="https://learn.javascript.ru/promise-basics" rel="nofollow">здесь</a> и <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="nofollow">здесь</a>.<br/>
        <br/>
        <a name="51"></a><h4>51. Что такое async/await?</h4><br/>
        Async/await — относительно новый способ написания асинхронного (неблокирующего) кода в JS. Им оборачивают промис. Он делает код более читаемым и чистым, чем промисы и функции обратного вызова. Однако для использования async/await необходимо хорошо знать промисы.<br/>
        <br/>
        <pre><code class="javascript">// промис
        function callApi(){
            return fetch('url/to/api/endpoint')
            .then(resp => resp.json())
            .then(data => {
                // работаем с данными
            }).catch(err => {
                // работаем с ошибкой
            })
        }
        
        // async/await
        // для перехвата ошибок используется try/catch
        async function callApi(){
            try{
                const resp = await fetch('url/to/api/endpoint')
                const data = await res.json()
                // работаем с данными
            } catch(e){
                // работаем с ошибкой
            }
        }
        </code></pre><br/>
        Запомните: использование ключевого слова «async» перед функцией заставляет ее возвращать промис:<br/>
        <br/>
        <pre><code class="javascript">const giveMeOne = async () = 1
        
        giveMeOne()
        .then((num) => {
            console.log(num) // 1
        })
        </code></pre><br/>
        Ключевое слово «await» можно использовать только внутри асинхронной функции. Использование «await» внутри другой функции приведет к ошибке. Await ожидает завершения выражения справа, чтобы вернуть его значение перед выполнением следующей строчки кода.<br/>
        <br/>
        <pre><code class="javascript">const giveMeOne = async() => 1
        
        function getOne(){
            try{
                const num = await giveMeOne()
                console.log(num)
            } catch(e){
                console.log(e)
            }
        }
        // Uncaught SyntaxError: await is only valid in an async function
        
        async function getTwo(){
            try{
                const num1 = await giveMeOne()
                const nm2 = await giveMeOne()
                return num1 + num2
            } catch(e){
                console.log(e)
            }
        }
        
        await getTwo() // 2
        </code></pre><br/>
        Подробнее об async/await можно почитать <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/async_function" rel="nofollow">здесь</a> и <a href="https://learn.javascript.ru/async-await" rel="nofollow">здесь</a>.<br/>
        <br/>
        <a name="52"></a><h4>52. В чем разница между spread-оператором и rest-оператором?</h4><br/>
        Операторы spread и rest имеют одинаковый синтаксис ("..."). Разница состоит в том, что с помощью spread мы передаем или распространяем данные массива на другие данные, а с помощью rest — получаем все параметры функции и помещаем их в массив (или извлекаем часть параметров).<br/>
        <br/>
        <pre><code class="javascript">function add(a, b){
            return a + b
        }
        
        const nums = [5, 6]
        const sum = add(...nums)
        console.log(sum) // 11
        </code></pre><br/>
        В этом примере мы используем spread при вызове функции add с данными массива nums. Значением переменной «a» будет 5, b = 6, sum = 11.<br/>
        <br/>
        <pre><code class="javascript">function add(...rest){
            return rest.reduce((total, current) => total + current)
        }
        
        console.log(add(1, 2)) // 3
        console.log(add(1, 2, 3, 4, 5)) // 15
        </code></pre><br/>
        Здесь мы вызываем функцию add с любым количеством аргументов. Add возвращает сумму этих аргументов.<br/>
        <br/>
        <pre><code class="javascript">const [first, ...others] = [1, 2, 3, 4, 5]
        console.log(first) // 1
        console.log(others) // [2, 3, 4, 5]
        </code></pre><br/>
        В этом примере мы используем rest для помещения любого количества параметров, кроме первого, в массив others.<br/>
        <br/>
        <a name="53"></a><h4>53. Что такое параметры по умолчанию (Default Parameters)?</h4><br/>
        Это относительно новый способ определения значений переменных по умолчанию.<br/>
        <br/>
        <pre><code class="javascript">// ES5
        function add(a,b){
            a = a || 0
            b = b || 0
            return a + b
        }
        
        // ES6
        function add(a = 0, b = 0){
            return a + b
        }
        // если мы не присвоим переменным "a" и "b" какие-нибудь значения, они будут равняться 0
        add(1) // 1
        </code></pre><br/>
        Можно использовать деструктуризацию:<br/>
        <br/>
        <pre><code class="javascript">function getFirst([first, ...rest] = [0, 1]){
            return first
        }
        
        getFirst() // 0
        getFirst([10,20,30]) // 10
        
        function getArr({ nums } = { nums: [1,2,3,4] }){
            return nums
        }
        
        getArr // [1,2,3,4]
        getArr({nums:[5,4,3,2,1]}) // [5,4,3,2,1]
        </code></pre><br/>
        Мы даже можем использовать по умолчанию параметры, объявленные в том же месте:<br/>
        <br/>
        <pre><code class="javascript">function doSomethingWithValue(value = 'Hello World', callback = () => { console.log(value) }){
            callback()
        }
        doSomethingWithValue() // Hello World
        </code></pre><br/>
        <a name="54"></a><h4>54. Что такое объектная обертка (Wrapper Objects)?</h4><br/>
        Примитивы строка, число и boolean имеют свойства и методы, несмотря на то, что они не являются объектами:<br/>
        <br/>
        <pre><code class="javascript">let name = 'marko'
        
        console.log(typeof name) // string
        console.log(name.toUpperCase()) // MARKO
        </code></pre><br/>
        Name — это строка (примитивный тип), у которого нет свойств и методов, но когда мы вызываем метод toUpperCase(), это приводит не к ошибке, а к «MARKO».<br/>
        <br/>
        Причина такого поведения заключается в том, что name временно преобразуется в объект. У каждого примитива, кроме null и undefined, есть объект-обертка. Такими объектами являются String, Number, Boolean, Symbol и BigInt. В нашем случае код принимает следующий вид:<br/>
        <br/>
        <pre><code class="javascript">console.log(new String(name).toUpperCase()) // MARKO
        </code></pre><br/>
        Временный объект отбрасывается по завершении работы со свойством или методом.<br/>
        <br/>
        <a name="55"></a><h4>55. В чем разница между явным и неявным преобразованием или приведением к типу (Implicit and Explicit Coercion)?</h4><br/>
        Неявное преобразование — это способ приведения значения к другому типу без нашего ведома (участия).<br/>
        <br/>
        Предположим, у нас есть следующее:<br/>
        <br/>
        <pre><code class="javascript">console.log(1 + '6')
        console.log(false + true)
        console.log(6 * '2')
        </code></pre><br/>
        Результатом первого console.log будет 16. В других языках это привело бы к ошибке, но в JS 1 конвертируется в строку и конкатенируется (присоединяется) c 6. Мы ничего не делали, преобразование произошло автоматически.<br/>
        <br/>
        Результатом второго console.log будет 1. False было преобразовано в 0, true — в 1. 0 + 1 = 1.<br/>
        <br/>
        Результатом третьего console.log будет 12. Строка 2 была преобразована в число перед умножением на 6.<br/>
        <br/>
        Явное преобразование предполагает наше участие в приведении значения к другому типу:<br/>
        <br/>
        <pre><code class="javascript">console.log(1 + parseInt('6'))
        </code></pre><br/>
        В этом примере мы используем parseInt для приведения строки 6 к числу, затем складываем два числа и получаем 7.<br/>
        <br/>
        <a name="56"></a><h4>56. Что такое NaN? Как проверить, является ли значение NaN?</h4><br/>
        NaN или Not A Number (не число) — это значение, получаемое в результате выполнения числовой операции над нечисловым значением:<br/>
        <br/>
        <pre><code class="javascript">let a
        
        console.log(parseInt('abc'))
        console.log(parseInt(null))
        console.log(parseInt(undefined))
        console.log(parseInt(++a))
        console.log(parseInt({} * 10))
        console.log(parseInt('abc' - 2))
        console.log(parseInt(0 / 0))
        console.log(parseInt('10a' * 10))
        </code></pre><br/>
        В JS есть встроенный метод isNaN, позволяющий проверять, является ли значение NaN, но он ведет себя довольно странно:<br/>
        <br/>
        <pre><code class="javascript">console.log(isNaN()) // true
        console.log(isNaN(undefined)) // true
        console.log(isNaN({})) // true
        console.log(isNaN(String('a'))) // true
        console.log(isNaN(() => { })) // true
        </code></pre><br/>
        Результатом всех console.log является true, несмотря на то, что ни одно из значений не является NaN.<br/>
        <br/>
        ES6 для проверки, является ли значение NaN, рекомендует использовать метод Number.isNaN. Мы также можем написать вспомогательную функцию для решения проблемы «неравенства NaN самому себе»:<br/>
        <br/>
        <pre><code class="javascript">function checkIsNan(value){
            return value !== value
        }
        </code></pre><br/>
        <a name="57"></a><h4>57. Как проверить, является ли значение массивом?</h4><br/>
        Для этого следует использовать метод Array.isArray:<br/>
        <br/>
        <pre><code class="javascript">console.log(Array.isArray(5)) // false
        console.log(Array.isArray('')) // false
        console.log(Array.isArray()) // false
        console.log(Array.isArray(null)) // false
        console.log(Array.isArray( {length: 5 })) // false
        console.log(Array.isArray([])) // true
        </code></pre><br/>
        Если среда, в которой Вы работаете, не поддерживает данный метод, можете использовать такой полифил:<br/>
        <br/>
        <pre><code class="javascript">function isArray(value){
            return Object.prototype.toString.call(value) === '[object Array]'
        }
        </code></pre><br/>
        <a name="58"></a><h4>58. Как проверить, что число является четным, без использования деления по модулю или деления с остатком (оператора "%")?</h4><br/>
        Для решения данной задачи можно использовать оператор "&amp;" (бинарное и). Оператор "&amp;" сравнивает операнды как бинарные значения.<br/>
        <br/>
        <pre><code class="javascript">function isEven(num){
            if(num &amp; 1){
                return false
            } else{
                return true
            }
        }
        </code></pre><br/>
        0 в бинарной системе счисления это 000<br/>
        1 — это 001<br/>
        2 — 010<br/>
        3 — 011<br/>
        4 — 100<br/>
        5 — 101<br/>
        6 — 110<br/>
        7 — 111<br/>
        и т.д.<br/>
        <br/>
        <img src="https://habrastorage.org/r/w1560/webt/y8/zo/m2/y8zom220osynreetfh8fp-dkuog.png" data-src="https://habrastorage.org/webt/y8/zo/m2/y8zom220osynreetfh8fp-dkuog.png"/><br/>
        <br/>
        Console.log(5 &amp; 1) вернет 1. Сначала оператор "&amp;" конвертирует оба числа в бинарные значения, 5 превращается в 101, 1 — в 001. Затем производится побитовое сравнение:<br/>
        <br/>
        <img src="https://habrastorage.org/r/w1560/webt/vy/4k/em/vy4kemefvzxgjlwdp3dmsh64ae8.png" data-src="https://habrastorage.org/webt/vy/4k/em/vy4kemefvzxgjlwdp3dmsh64ae8.png"/><br/>
        <br/>
        Сравниваем 1 и 0, получаем 0.<br/>
        Сравниваем 0 и 0, получаем 0.<br/>
        Сравниваем 1 и 1, получаем 1.<br/>
        Преобразуем бинарное значение в целое число, получаем 1.<br/>
        <br/>
        Если эта информация кажется Вам слишком сложной, мы можем решить поставленную задачу с помощью рекурсивной функции:<br/>
        <br/>
        <pre><code class="javascript">function isEven(num){
            if(num &lt; 0 || num === 1) return false
            if(num == 0) return true
            return isEven(num - 2)
        }
        </code></pre><br/>
        <a name="59"></a><h4>59. Как определить наличие свойства в объекте?</h4><br/>
        Существует три способа это сделать.<br/>
        <br/>
        Первый способ состоит в использовании оператора «in»:<br/>
        <br/>
        <pre><code class="javascript">const o = {
            'prop': 'bwahahah',
            'prop2': 'hweasa'
        }
        
        console.log('prop' in o) // true
        console.log('prop1' in o) // false
        </code></pre><br/>
        Второй — использовать метод hasOwnProperty:<br/>
        <br/>
        <pre><code class="javascript">console.log(o.hasOwnProperty('prop2')) // true
        console.log(o.hasOwnProperty('prop1')) // false
        </code></pre><br/>
        Третий — индексная нотация массива:<br/>
        <br/>
        <pre><code class="javascript">console.log(o['prop']) // bwahahah
        console.log(o['prop1']) // undefined
        </code></pre><br/>
        <a name="60"></a><h4>60. Что такое AJAX?</h4><br/>
        AJAX или Asyncronous JavaScript and XML — это набор взаимосвязанных технологий, которые позволяют работать с данными в асинхронном режиме. Это означает, что мы можем отправлять данные на сервер и получать данные с него без перезагрузки веб-страницы.<br/>
        <br/>
        AJAX использует следующие технологии:<br/>
        HTML — структура веб-страницы.<br/>
        CSS — стили веб-страницы.<br/>
        JavaScript — поведение страницы и работа с DOM.<br/>
        XMLHttpRequest API — отправка и получение данных с сервера.<br/>
        PHP, Python, Nodejs — какой-нибудь серверный язык.<br/>
        <br/>
        <a name="61"></a><h4>61. Как в JS создать объект?</h4><br/>
        Объектный литерал:<br/>
        <br/>
        <pre><code class="javascript">const o = {
            name: 'Mark',
            greeting(){
                return `Hi, I'm ${this.name}`
            }
        }
        
        o.greeting // Hi, I'm Mark
        </code></pre><br/>
        Функция-конструктор:<br/>
        <br/>
        <pre><code class="javascript">function Person(name){
            this.name = name
        }
        
        Person.prototype.greeting = function(){
            return `Hi, I'm ${this.name}`
        }
        
        const mark = new Person('Mark')
        
        mark.greeting() // Hi, I'm Mark
        </code></pre><br/>
        Метод Object.create:<br/>
        <br/>
        <pre><code class="javascript">const n = {
            greeting(){
                return `Hi, I'm ${this.name}`
            }
        }
        
        const o = Object.create(n)
        
        o.name = 'Mark'
        
        console.log(o.greeting) // Hi, I'm Mark
        </code></pre><br/>
        <a name="62"></a><h4>62. В чем разница между методами Object.freeze и Object.seal?</h4><br/>
        Разница заключается в том, что при использовании метода Object.freeze мы не можем менять или редактировать свойства объекта, а при использовании Object.seal у нас такая возможность имеется.<br/>
        <br/>
        <a name="63"></a><h4>63. В чем разница между оператором «in» и методом hasOwnProperty?</h4><br/>
        Отличие состоит в том, что оператор «in» проверяет наличие свойства не только в самом объекте, но и в его прототипах, а метод hasOwnProperty — только в объекте.<br/>
        <br/>
        <pre><code class="javascript">console.log('prop' in o) // true
        console.log('toString' in o) // true
        
        console.log(o.hasOwnProperty('prop')) // true
        console.log(o.hasOwnProperty('toString')) // false
        </code></pre><br/>
        <a name="64"></a><h4>64. Какие приемы работы с асинхронным кодом в JS Вы знаете?</h4><br/>
        <ul>
        <li>Функции обратного вызова (Callbacks).</li>
        <li>Промисы (Promises).</li>
        <li>Async/await.</li>
        <li>Библиотеки вроде async.js, blueprint, q, co.</li>
        </ul><br/>
        <a name="65"></a><h4>65. В чем разница между обычной функцией и функциональным выражением?</h4><br/>
        Допустим, у нас есть следующее:<br/>
        <br/>
        <pre><code class="javascript">hoistedFunc()
        notHoistedFunc()
        
        function hoistedFunc(){
            console.log('I am hoisted')
        }
        
        var notHoistedFunc = function(){
            console.log('I will not be hoisted!')
        }
        </code></pre><br/>
        Вызов notHoistedFunc приведет к ошибке, а вызов hoistedFunc нет, потому что hoistedFunc «всплывает», поднимается в глобальную область видимости, а notHoistedFunc нет.<br/>
        <br/>
        <a name="66"></a><h4>66. Как в JS вызвать функцию?</h4><br/>
        В JS существует 4 способа вызвать функцию. Вызов определяет значение this или «владельца» функции.<br/>
        <br/>
        Вызов в качестве функции. Если функция вызывается как метод, конструктор или с помощью методов apply или call, значит она вызывается как функция. Владельцем такой функции является объект window:<br/>
        <br/>
        <pre><code class="javascript">function add(a,b){
            console.log(this)
            return a + b
        }
        
        add(1,5) // window, 6
        
        const o = {
            method(callback){
                callback()
            }
        }
        
        o.method(function(){
            console.log(this) // window
        })
        </code></pre><br/>
        Вызов в качестве метода. Когда функция является свойством объекта, мы называем ее методом. Когда вызывается метод, значением this становится объект этого метода:<br/>
        <br/>
        <pre><code class="javascript">const details = {
            name: 'Marko',
            getName(){
                return this.name
            }
        }
        
        details.getName() // Marko, значением this является объект details
        </code></pre><br/>
        Вызов в качестве конструктора. Когда функция вызывается с использованием ключевого слова «new», мы называем такую функцию конструктором. При этом создается пустой объект, являющийся значением this:<br/>
        <br/>
        <pre><code class="javascript">function Employee(name, position, yearHired){
            // создается пустой объект, являющийся значением this
            // this = {}
            this.name = name
            this.position = position
            this.yearHired = yearHired
            // наследование от Employee.prototype неявно возвращает this, если не указано иное
        }
        
        const emp = new Employee('Marko Polo', 'Software Development', 2017)
        </code></pre><br/>
        Вызов с помощью методов apply или call. Мы используем эти методы, когда хотим явно определить значение this или владельца функции:<br/>
        <br/>
        <pre><code class="javascript">const obj1 = {
            result: 0
        }
        
        const obj2 = {
            result: 0
        }
        
        function reduceAdd(){
            let result = 0
            for(let i = 0, len = arguments.length; i &lt; len; i++){
                result += arguments[i]
            }
            this.result = result
        }
        
        reduceAdd.apply(obj1, [1,2,3,4,5]) // значением this является obj1
        reduceAdd.call(obj2, 1,2,3,4,5) // значением this является obj2
        </code></pre><br/>
        <a name="67"></a><h4>67. Что такое запоминание или мемоизация (Memoization)?</h4><br/>
        Мемоизация — это прием создания функции, способной запоминать ранее вычисленные результаты или значения. Преимущество мемоизации заключается в том, что мы избегаем повторного выполнения функции с одинаковыми аргументами. Недостатком является то, что мы вынуждены выделять дополнительную память для сохранения результатов.<br/>
        <br/>
        <a name="68"></a><h4>68. Как бы Вы реализовали вспомогательную функцию запоминания?</h4><br/>
        <pre><code class="javascript">function memoize(fn){
            const cache = {}
            return function(param){
                if(cache[param]){
                    console.log('cached')
                    return cache[param]
                } else{
                    let result = fn(param)
                    cache[param] = result
                    console.log('not cached')
                    return result
                }
            }
        }
        
        const toUpper = (str = '') => str.toUpperCase()
        
        const toUpperMemoized = memoize(toUpper)
        
        toUpperMemoized('abcdef')
        toUpperMemoized('abcdef') // не выполнится
        </code></pre><br/>
        Мы реализовали функцию мемоизации с одним аргументом. Сделаем ее «мультиаргументной»:<br/>
        <br/>
        <pre><code class="javascript">const slice = Array.prototype.slice
        function memoize(fn){
            const cache = {}
            return (...args) => {
                const params = slice.call(args)
                console.log(params)
                if(cache[params]){
                    console.log('cached')
                    return cache[params]
                } else{
                    let result = fn(...args)
                    cache[params] = result
                    console.log('not cached')
                    return result
                }
            }
        }
        const makeFullName = (fName, lName) => `${fName} ${lName}`
        const reduceAdd = (numbers, startValue = 0) => numbers.reduce((total, cur) => total + cur, startValue)
        
        const memoizedFullName = memoize(makeFullName)
        const memoizeReduceAdd = memoize(reduceAdd)
        
        memoizedFullName('Marko', 'Polo')
        memoizedFullName('Marko', 'Polo') // не выполнится
        
        memoizeReduceAdd([1,2,3,4],5)
        memoizeReduceAdd([1,2,3,4],5) // не выполнится
        </code></pre><br/>
        <a name="69"></a><h4>69. Почему typeof null возвращает object? Как проверить, является ли значение null?</h4><br/>
        typeof null == 'object' всегда будет возвращать true по историческим причинам. Поступало предложение исправить эту ошибку, изменив typeof null = 'object' на typeof null = 'null', но оно было отклонено в интересах сохранения обратной совместимости (такое изменение повлекло бы за собой большое количество ошибок).<br/>
        <br/>
        Для проверки, является ли значение null можно использовать оператор строгого равенства (===):<br/>
        <br/>
        <pre><code class="javascript">function isNull(value){
            return value === null
        }
        </code></pre><br/>
        <a name="70"></a><h4>70. Для чего используется ключевое слово «new»?</h4><br/>
        Ключевое слово «new» используется в функциях-конструкторах для создания нового объекта (нового экземпляра класса).<br/>
        <br/>
        Допустим, у нас есть такой код:<br/>
        <br/>
        <pre><code class="javascript">function Employee(name, position, yearHired){
            this.name = name
            this.position = position
            this.yearHired = yearHired
        }
        
        const emp = new Employee('Marko Polo', 'Software Development', 2017)
        </code></pre><br/>
        Ключевое слово «new» делает 4 вещи:<br/>
        <br/>
        <ol>
        <li>Создает пустой объект.</li>
        <li>Привязывает к нему значение this.</li>
        <li>Функция наследует от functionName.prototype.</li>
        <li>Возвращает значение this, если не указано иное.</li>

        
    </div>
   </body>
</html>